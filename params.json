{"name":"Dating-game","tagline":"Architecture for \"Dating Game\" for Dennis Shasha's Heuristic Problem Solving course at NYU","body":"Architecture for \"Dating Game\" for Dennis Shasha's Heuristic Problem Solving course at NYU\r\n\r\nProblem Description\r\n===================\r\n\r\nMatchmaker M is trying to figure out what kind of person P wants to date. So, M arranges many dates for P. \r\nP will report to M how much P likes those dates (score between -1 and 1, where 1 is good and -1 is very bad). \r\nP's criteria for liking a date or not depend on the weights P gives to various attributes -- e.g. \r\nliterary knowledge, ability to solve puzzles, and others. The weights may be positive or negative \r\nranging from -1 to 1 and specified as decimal values having at most two digits to the right of the \r\ndecimal point, e.g. 0.13 but not 0.134. In each response, P may modify 5% of the criteria (P may choose \r\nwhich ones) by 20% each. For example, if a chosen criterion has a weight of 0.4 in P's original criteria, \r\nthen P can modify it to any value between 0.4 - (0.2*0.4) and 0.4 + (0.2*0.4). P does these modifications \r\nwithout seeing any information provided by M.\r\n\r\nA candidate C has values for each of n (not more than 100) attributes -- each value lies between 0 and 1 \r\ninclusive and may be an arbitrary precision number. Given the weights P has assigned to each attribute w1, ..., wn \r\nand the values C has for each attribute v1, ..., vn, the score P gives to C is simply the dot product of the two \r\nvectors. P must set up his or her weights so (before modification) there is an ideal matching candidate that gets\r\na score of 1 and an anti-ideal candidate that gets a score of -1. No candidate should get a score below -1 or \r\nabove 1. That is, the sum of P's positive weights (before modification) must be 1 and the sum of the negative\r\nweights must be -1. After modification, the sum of the positive weights may no longer be +1 and the sum of the \r\nnegative weights may no longer be -1. Hence the ideal candidate will consist solely of 1s and 0s.\r\n\r\nYou will play two roles: P and M. As P you set up your weights meeting the constraints above and send them \r\nto the architect. In every round, P may also change the weights though without knowledge of the candiate \r\nsuggested by M. The architect will then generate 20 candidates with values between 0 and 1. As M you manufacture \r\nup to 20 candidates meeting the candidate constraints and receive scores from the architect iteratively. If \r\nyou receive a score of 1 (using the pre-modification weights) you stop and the architect records how many \r\ncandidates you required. Otherwise, you receive the score you obtained after your 20 candidates. The value of \r\nM is the lexicographic value (score, number of candidates) A player X beats player Y if X obtains a greater \r\nscore or obtains the same score but with fewer candidates than Y does for X's P.\r\nArchitecture Team\r\n\r\nReceive weights for P from a file, verify attributes of an ideal candidate and an anti-ideal one (both \r\nprovided by the player who puts up P). Then the architect generates 20 random candidates and provides those \r\nweights and their scores to the matchmaker. These occur without modifications. Then receive iteratively a \r\nsequence of candidates from the M player (as well as modification instructions from P) and a conclusion as \r\nto weights and as to ideal candidate. Supervise time constraint on the M player. Keep track of how many\r\ncandidates M has used if successful.\r\n\r\nHere is the loop:\r\n\r\nuntil matchmaker has completed 20 candidates or received a score of 1\r\nmatchmaker submits a candidate\r\nP submits modification instructions (without knowing anything about the candidate)\r\narchitect returns the score after modification and displays the candidates\r\nend until\r\n\r\nMatchmaker records score and number of candidates proposed by matchmaker.\r\n\r\nInformation about P should come in as a file regarding the person but socket regarding the candidates.\r\n\r\nArchitect should put out the candidate value vector and return the scores. ","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}